---
layout:     post
title:      2020-07-07-R Graphics Cookbook读书笔记2
subtitle:   第三章-条形图
date:       2020-07-07
author:     DL
header-img: img/home-bg-o.jpg
catalog: true
tags:
    - R Graphics
---

> 参考资料：[R Graphics Cookbook, 2nd edition](https://r-graphics.org/)

## 第三章 条形图（Bar Graphs）

&emsp;&emsp;条形图可能是最常用的数据可视化类型。它们通常用于显示不同类别（在x轴上）的数值（在y轴上）。举例来说，条形图可以很好地显示四种不同商品的价格。但是，条形图通常不适合显示随时间变化的价格（因为时间是一个连续变量）。

&emsp;&emsp;在制作条形图时，有一点需要意识到：条形图的高度有时候代表的是数据集中case的统计数目，而有时它们代表的则是数据集中具体的数值。由于count和value与具体数据间的关系有着很大的差异，因此可能会引起混淆。

### 3.1 创建一个简单的条形图

使用ggplot()中的geom_col()，并指定x和y轴的数据。

```
library(gcookbook)  # Load gcookbook for the pg_mean data set
ggplot(pg_mean, aes(x = group, y = weight)) +
  geom_col()
```

![UkyjPK.png](https://s1.ax1x.com/2020/07/07/UkyjPK.png)

> 注：在早期的ggpolot2版本中，使用geom_bar(stat="identity")来创建条形图，而新版本则使用geom_col()。

当x是一个连续型（或数字型）变量时，条形图的呈现会略有差异（比如下图x轴在6的地方出现了隔断）。此时可以利用factor()函数将连续型变量转换为离散型变量。

```
# There's no entry for Time == 6
BOD
#>   Time demand
#> 1    1    8.3
#> 2    2   10.3
#> 3    3   19.0
#> 4    4   16.0
#> 5    5   15.6
#> 6    7   19.8

# Time is numeric (continuous)
str(BOD)
#> 'data.frame':    6 obs. of  2 variables:
#>  $ Time  : num  1 2 3 4 5 7
#>  $ demand: num  8.3 10.3 19 16 15.6 19.8
#>  - attr(*, "reference")= chr "A1.4, p. 270"

ggplot(BOD, aes(x = Time, y = demand)) +
  geom_col()

# Convert Time to a discrete (categorical) variable with factor()
ggplot(BOD, aes(x = factor(Time), y = demand)) +
  geom_col()
```

![UkcnfK.png](https://s1.ax1x.com/2020/07/07/UkcnfK.png)

![Ukc80A.png](https://s1.ax1x.com/2020/07/07/Ukc80A.png)

&emsp;&emsp;注意，BOD数据中并中没有Time = 6的行。当x为连续型变量时，ggplot2将使用一个数字轴，该轴会为最小值到最大值范围内的所有数值保留空间（在本图中，虽然x中没有6这一行，但是会保留该space）。

&emsp;&emsp;将Time数据转换为factor后，ggplot2会将其当作离散型变量来处理，该变量的值将被视为任意的标签（而非数字），因此它将不会在x轴上为最小值和最大值之间的所有可能数值分配空间。

&emsp;&emsp;ggplot2中条形图的默认颜色为深灰色。若要更换颜色填充，可以利用fill参数进行修改。另外，默认情况下，填充的周围是没有轮廓的，若要添加轮廓，则需使用colour参数。

```
# 使用淡蓝色的fill和黑色的轮廓
ggplot(pg_mean, aes(x = group, y = weight)) +
  geom_col(fill = "lightblue", colour = "black")
```

### 3.2 创建分组条形图（geom_col(position = "dodge")）

下面将使用cabbage_exp数据集进行演示，该数据包含两个分类变量（**Cultivar和Date**）和一个连续型变量（**Weight**）：

```
library(gcookbook)  # Load gcookbook for the cabbage_exp data set
cabbage_exp
#>   Cultivar Date Weight        sd  n         se
#> 1      c39  d16   3.18 0.9566144 10 0.30250803
#> 2      c39  d20   2.80 0.2788867 10 0.08819171
#> 3      c39  d21   2.74 0.9834181 10 0.31098410
#> 4      c52  d16   2.26 0.4452215 10 0.14079141
#> 5      c52  d20   3.11 0.7908505 10 0.25008887
#> 6      c52  d21   1.47 0.2110819 10 0.06674995
```

我们将**Date**映射到x轴，将**Weight**映射到y轴，将**Cultivar**映射到fill color：

```
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
  geom_col(position = "dodge")
```

![UV0XUP.png](https://s1.ax1x.com/2020/07/08/UV0XUP.png)


&emsp;&emsp;对于大部分的条形图来说，x轴一般为分类变量（categorical variable），y轴一般为连续型变量（continuous variable）。有时候我们还想引入另一个分类变量用于创建分组条形图，此时我们便可用**position = "dodge**参数来完成。

&emsp;&emsp;注意：条形图的x轴一定要是categorical variable，而非continuous variable。如果想给条形图绘制外框，可在geom_col()中加入参数colour="black"。如果要设置条形图的颜色，则需使用scale_fill_brewer()或scale_fill_manual()参数。下图使用的是RColorBrewer中的Pastel1这个调色板：

```
ggplot(cabbage_exp, aes(x = Date, y = Weight, fill = Cultivar)) +
  geom_col(position = "dodge", colour = "black") +
  scale_fill_brewer(palette = "Pastel1")
```

![UVBbzF.png](https://s1.ax1x.com/2020/07/08/UVBbzF.png)

---

### 创建基于计数（counts）的条形图

使用geom_bar()函数，但不映射任何值给y轴：

```
# Equivalent to using geom_bar(stat = "bin")
ggplot(diamonds, aes(x = cut)) +
  geom_bar()
```

![UVs5dA.png](https://s1.ax1x.com/2020/07/08/UVs5dA.png)

```
diamonds
#> # A tibble: 53,940 x 10
#>   carat cut       color clarity depth table price     x     y     z
#>   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>
#> 1 0.23  Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43
#> 2 0.21  Premium   E     SI1      59.8    61   326  3.89  3.84  2.31
#> 3 0.23  Good      E     VS1      56.9    65   327  4.05  4.07  2.31
#> 4 0.290 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63
#> 5 0.31  Good      J     SI2      63.3    58   335  4.34  4.35  2.75
#> 6 0.24  Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48
#> # … with 53,934 more rows
```

上图我们对diamonds数据集中的**cut**这一列进行了计数，并绘制了条形图，cut列是离散的。如果我们使用连续型变量进行计数条形图的绘制，则效果如下：

![UV6fUA.png](https://s1.ax1x.com/2020/07/08/UV6fUA.png)

x轴连续的条形图类似于直方图，但不相同。在条形图中，每个条形表示一个唯一的x值，而在直方图中，每个条形表示一个x值的范围。

>附录：条形图和直方图的区别
> 
> 1、条形图是用条形的长度表示各类别频数的多少，其宽度（表示类别）则是固定的； 直方图是用面积表示各组频数的多少，矩形的高度表示每一组的频数或频率，宽度则表示各组的组距，因此其高度与宽度均有意义。 
>
>2、由于分组数据具有连续性，直方图的各矩形通常是连续排列，而条形图则是分开排列。
>
>3、条形图主要用于展示分类数据，而直方图则主要用于展示数据型数据

---

### 在条形图中使用不同的颜色

此例我们将使用**uspopchange**数据集，其包含了美国从2000年到2010年的人口变化百分比。我们将使用人口增速最快的前十个州，并绘制出它们的百分比变化。我们还将按地区（东北，南部，中北部或西部）对条形进行着色。首选需要获得排名前十的州的数据：

```
library(gcookbook) # Load gcookbook for the uspopchange data set
library(dplyr)

upc <- uspopchange %>%
  arrange(desc(Change)) %>%
  slice(1:10)

upc
#>             State Abb Region Change
#> 1          Nevada  NV   West   35.1
#> 2         Arizona  AZ   West   24.6
#> 3            Utah  UT   West   23.8
#>  ...<4 more rows>...
#> 8         Florida  FL  South   17.6
#> 9        Colorado  CO   West   16.9
#> 10 South Carolina  SC  South   15.3
```

下面开始作图:

```
ggplot(upc, aes(x = Abb, y = Change, fill = Region)) +
  geom_col()
```

![UZwdgg.png](https://s1.ax1x.com/2020/07/08/UZwdgg.png)

默认颜色为湖绿和西瓜红，若想更改条形图的颜色，可以使用scale_fill_brewer()函数或scale_fill_manual()函数。此例将使用scale_fill_manual()函数来更改颜色，使用colour="black"来绘制条形图的外框颜色。

```
ggplot(upc, aes(x = reorder(Abb, Change), y = Change, fill = Region)) +
  geom_col(colour = "black") +
  scale_fill_manual(values = c("#669933", "#FFCC66")) +
  xlab("State")
```

![UZ0uaq.png](https://s1.ax1x.com/2020/07/08/UZ0uaq.png)

注意，在上述例子中，我们还使用了reorder()函数，基于Change的值来对factor Abb进行重新排序。由上图可知，相比于按照factor Abb的字母顺序，这种按照条形图高度进行排序的方式显得更加合理。

---

### 3.5 为正负条形图分别上色

我们将使用一部分气候数据，并创建一个称为pos的新列，该列可以指明该值是正数还是负数：

```
library(gcookbook) # Load gcookbook for the climate data set
library(dplyr)

climate_sub <- climate %>%
  filter(Source == "Berkeley" & Year >= 1900) %>%
  mutate(pos = Anomaly10y >= 0)

climate_sub
#>       Source Year Anomaly1y Anomaly5y Anomaly10y Unc10y   pos
#> 1   Berkeley 1900        NA        NA     -0.171  0.108 FALSE
#> 2   Berkeley 1901        NA        NA     -0.162  0.109 FALSE
#> 3   Berkeley 1902        NA        NA     -0.177  0.108 FALSE
#>  ...<99 more rows>...
#> 103 Berkeley 2002        NA        NA      0.856  0.028  TRUE
#> 104 Berkeley 2003        NA        NA      0.869  0.028  TRUE
#> 105 Berkeley 2004        NA        NA      0.884  0.029  TRUE
```

一旦我们获得了数据，便可以开始绘制条形图，我们使用position="identity"参数，以防因负数而出现警告消息：

```
ggplot(climate_sub, aes(x = Year, y = Anomaly10y, fill = pos)) +
  geom_col(position = "identity")
```

![UZDqP0.png](https://s1.ax1x.com/2020/07/08/UZDqP0.png)

上图有几个问题：首先，颜色和我们所期望的相反，一般来说，红色代表热，蓝色代表冷；其次，图例是多余的。

我们可以使用scale_fill_manual()参数来改变颜色，使用guide=FLASE来移除图例，使用colour参数来改变条形图的外框颜色，使用size参数来改变外框的粗细。

```
ggplot(climate_sub, aes(x = Year, y = Anomaly10y, fill = pos)) +
  geom_col(position = "identity", colour = "black", size = 0.25) +
  scale_fill_manual(values = c("#CCEEFF", "#FFDDDD"), guide = FALSE)
```

![UZrRoR.png](https://s1.ax1x.com/2020/07/08/UZrRoR.png)